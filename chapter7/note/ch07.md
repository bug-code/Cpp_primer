@[TOC](类)

# 类
**类的基本思想：** 
- 数据抽象
- 封装

类的接口包括用户所能执行的操作；类的实现包括类的数据成员，负责接口实现的函数以及定义类所需的各种私有函数。

## 成员函数与非成员函数
**成员函数：** 必须声明在类的内部，可在类的内部定义，也可在类的外部定义。(`隐式的inline函数`)
**非成员函数：** 声明与定义在类的外部


## This 指针
在成员函数内部，可以直接使用调用该函数的对象的成员，无须通过成员访问运算符，this代表的就是调用该函数的对象。
`包龙星：你是烂屁股(this指针)`
`李公公(调用this指针的对象)：你骂谁？`
`包龙星：谁搭腔我就骂谁(谁调用谁就代表this指针指向的对象)`
1. **This是一个指向常量对象的指针**
2. **常量对象、常量对象的引用、常量对象的指针都只能调用常量成员函数**

## const成员函数
**常量成员函数：**  把const关键字放在成员函数的参数列表之后，紧跟在参数列表后面的const表示this是一个指向常量的指针。

```
type function(parameter_list) const;
```
## 类作用域和成员函数
- 类内的成员函数可以直接使用类内的其他成员而无需在意次序。

**类编译流程：**
1. 编译成员的声明
2. 编译成员函数体

### 类外部定义成员函数
```
type 类名::成员函数名(形参列表) {//函数体//};
```
## 定义一个返回this对象的函数
- 返回this对象，因为this是指针，所以需解引用获得对象。***this**
- 返回对象，表明函数返回值为左值。从第6章中可知，当函数返回类型为引用时，返回值为左值，否则均为右值。因此返回类型需要定义为引用

## 类相关的非成员函数
某些函数定义的操作从概念上来说属于类的接口的组成部分，但并不属于类本身。
- **如果函数在概念上属于类但是不定义在类中，则它一般应与类声明在同一个头文件内。**

## 构造函数
**构造函数：**  类通过一个或几个特殊成员函数来控制其对象的初始化过程。这类函数称为构造函数。

1. 构造函数的名字和类名相同
2. 构造函数没有返回值
3. 构造函数可重载
4. 构造函数不能被声明成const
   
### 默认构造函数
**默认构造函数：** 通过一个特殊的构造函数来控制默认初始化过程。
1. 默认构造函数无任何实参
2. 默认构造函数产生的对象初始值是默认初始化的
3. 如果类内没有构造函数，则编译器会默认产生一个构造函数(合成的默认构造函数)

### 某些类不能依赖于合成的默认构造函数
**合成的默认构造函数只适合非常简单的类**
对于一个普通的类来说，必须定义它的默认构造函数
**原因：**
1. 只有当类美哟声明任何构造函数时，编译器才会自动生成默认构造函数
2. 含有内置类型或复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。否则，用户在创建类的对象时，就可能得到未定义的值
3. 有的编译器不能为某些类合成默认的构造函数

定义默认构造函数
```
类名()=default; //当有其他构造函数时，用这种方式要求编译器定义一个合成的默认构造函数
```

`=default`即可以和声明一起出现在类的内部，也可以作为定义出现在类的外部，在类内部时时内联的，在外部时不是内联的。

*如果编译器不支持类内初始值，则默认构造函数应该使用构造函数初始值列表来初始化每一个成员*

### 构造函数初始值列表

**构造函数初始值列表：** 冒号及冒号和花括号之间的代码

```
Sales_data(const std:: string &s):bookNo(s){}  // 初始值列表构造函数
Sales_data(const std::string &s , unsigned n , double p):bookNo(s) , units_sold(n),revenue(p*n){} //初始值列表构造函数
```
构造函数初始值列表负责为新建的对象的数据成员赋初值。
1. 当某个数据成员被构造函数初始值列表忽略时，它将以合成默认构造函数相同的方式隐式初始化。
2. 构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同
3. 如果不能使用类内初始值，则所有构造函数都应该显示的初始化每个内置类型的成员

### 在类的外部定义构造函数

```
Sales_data::Sales_data(std::istream &is){
    read(is,*this);
}
```
1. 类外部定义构造函数与类成员函数在类外部定义一样
2. 但是构造函数没有返回值，也就没有返回类型

### 构造函数初始化
如果成员是const、引用或者某种提供默认构造函数的类类型时，我们必须通过构造函数初始值列表为这些成员提供初始值。(因为const和引用必须有具体的对象，必须要初始化)
#### 构造函数初始化顺序
```
class X{
    int i;
    int j;
    public:
        X(int val):j(val),i(j);
};
```
在X类的初始化构造函数中，i是先被赋值的，因此i使用的是未被定义的值进行初始化的，这将造成错误。
#### 默认实参和构造函数
如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。
### 委托构造函数
**委托构造函数：** 一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把自己的一些值则委托给其他构造函数。

委托构造函数形式：

```
类名(形参列表):其他已定义的构造函数{函数体}
```


## 拷贝、赋值和析构
类除了需要构造函数外，还需要控制拷贝、赋值、和销毁对象时发生的行为。
1. 如果不主动定义这些操作，则编译器将替我们合成
2. 编译器生成的版本将对 对象的每个成员执行拷贝、赋值和销毁操作
### 对于某些类不能依赖于合成的版本
1. **当类需要分配类对象之外的资源时，合成的版本常常会失效。**
2. 管理动态内存的类通常不能依赖于这些操作的合成版本。
3. 需要动态内存的类能使用vector对象或string对象管理必要的存储空间，从而避免分配和释放内存带来的复杂性(**即vector和string的合成版本能正常操作**)

## 访问控制和封装
**访问说明符：** 用于加强类的封装性
1. **public访问说明符:** 定义在public说明符之后的成员在整个程序内可被访问，pubulic成员定义类的接口
2. **private访问说明符:** 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private隐藏了类的实现细节

### class或struct关键字
**区别：** 默认访问权限不同 。

1. **struct关键字：** 定义在第一个访问说明符之前的成员是public的
2. **class关键字：** 定义在第一个访问说明符之前的成员是private的 

- **当希望定义的类所有成员是public时用struct**
- **当希望定义的类的所有成员是private时用class**


## 友元
其他类或函数是该类接口的一部分，当其他类或函数想访问它的非公有成员时需要在该类的内部声明为**友元**。

**友元声明：**
在类内部，添加一条以`frined`为关键字的友元函数或友元类的声明。
**一般最好在类定义开始或结束的位置集中声明友元**

### 友元的声明
- 友元的声明仅指定了访问的权限，而非一个通常意义上的函数声明。
- 为了类的用户能够调用某个友元函数，必须在友元声明之外(类外部)再专门对函数进行一次声明。
- 为了使友元对类的用户可见，通常把友元的声明与类本身放置再同一个头文件中(类外部)。
### 友元再探
1. 类还可以把其他的类定义成友元
2. 也可以把其他类的成员函数定义成友元
3. 友元函数能定义在类的内部(隐式内联)

#### 友元类
**友元类的成员函数可以访问此类的所有成员**

**友元关系不存在传递性**
#### 另成员函数成为友元
除了令整个类作为某类的友元，还可以单独指定类中的某个成员函数成为另一个类的友元函数。
#### 重载函数和友元
尽管重载函数的名字相同，但它们仍是不同语言
#### 友元函数和作用域
友元函数一定要先声明再被类内的成员函数调用。
**类定义的一般步骤：**
1. 定义类
- 友元函数，类属性，构造函数，析构函数，成员函数
2. 友元函数声明，成员函数声明
3. 所有函数定义

**类内成员函数的声明仅仅是影响访问权限，而不是普通意义上的声明**







## 令成员为内联函数
在类内部定义的成员函数是自动成为内联函数的。但是如果在类内声明，在类外定义的成员函数则不是默认成为内联函数的。
**如果在类内声明，在类外定义则在定义时需要在函数前添加inline函数说明符**

### 成员函数是可以重载的

### 可变数据成员
某些时候，希望修改某个类的对象中的属性(即使该对象是常量对象)。但是当对象为常量对象时，则无法对其修改。

- 因此即使某个对象为常量对象的情况下，我们也希望修改其属性，就应该把该属性定义为可变数据成员

**可变数据成员：**  在任何情况下都能被修改的变量
**关键字：** `mutable` ， 在需要定义的变量前添加关键字即可

### 类数据成员的初始值
当提供一个类内初始值时，必须以符号=或花括号表示


## 返回*this的成员函数
当需要类成员函数返回类对象本身时就`return *this;`。表明该函数返回调用对象本身，从而可以使用连续`.`操作符

**例如：**
```
myScreen.move(4,0).set('#');
```
### 从const成员函数返回*this
如果一个成员函数返回的是*this本身，同时该成员函数的返回类型是const，则在后续的过程中无法对这个对象进行修改。因为执行完该成员函数后，对象成为了常量对象。
### 基于const的成员函数重载
对象是常量对象和非常量对象对成员函数的要求是不同的。

- 非常量版本的函数对于常量对象是不可用的
- 非常量对象虽然即可以调用非常量成员函数，也可以调用常量成员函数，但显然非常量成员函数是更好的选择

## 类类型成员
**每个类定义了唯一的类型，即使两个类的成员完全一样也是不同的类型**

### 类的声明
可以先声明类而不定义
**前向声明**
```
class Screen;//类声明
``` 
该类在声明之后定义之前是**非完全类型**

不完全类型只能在有限的情况下使用：
1. 可以定义指向这种类型的指针或引用
2. 可以**声明**(但不能定义)以不完全类型作为参数或返回类型的函数

**类的成员变量类型不能是类自己**(禁止套娃)
**一个类的名字出现后，即可认为被声明过了，因此可以在类内部定义成员变量，成员变量为指向该类的指针**(指针只要知道其指向对象的类型即可声明)

### 名字查找与类的作用域
类的定义分两步：
1. 编译成员声明
2. 知道类全部可见后才编译函数体
 
*编译器处理完类的全部声明后才会处理成员函数的定义*

#### 类型名要特殊处理
**如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能再之后重新定义该名字**

1. 尽管类的成员被隐藏了，但我们仍可以通过加上类的名字或显示地使用this指针来强制访问成员
2. 如果我们需要地是外层作用域中的名字，可以显示的通过作用域运算符来进行请求


## 隐式的类类型转换

**转换构造函数：** 如果一个类存在只接收一个实参的构造函数，则它实际上定义了转换为此类类型的隐式转换规则。

*能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换规则。*

示例
```
string null_book="9-999-99999-9"; //先将字面值转换为string类型
item.combine(null_book);    //再使用转换构造函数隐式转换成Sales_data类型
```
### 抑制构造函数定义的隐式转换
在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为`explicit`加以阻止隐式转换。

1. `explicit`关键字只针对一个实参的构造函数有效。
2. 只能在类内声明构造函数时使用该关键字，在类外部定义时不应重复。
3. `explicit`构造函数只能用于直接初始化


## 聚合类
**聚合类：**
1. 所有成员都是public
2. 没有定义任何构造函数
3. 没有类内初始值
4. 没有基类，也没有virtual函数。

集合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。

示例：
```
struct Data{
    int ival;
    string s;
};

Data vall={0,"Anna"};//初始化属性顺序一致，初始值列表元素个数不能超过类的成员属性数量
```
显式初始化类的对象成员存在三个缺点：
1. 要求所有成员都是public的
2. 将正确初始化每个对象的每个成员的重任交给了开发者。因为开发这很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错。
3. 添加或删除一个成员之后，所有的初始化语句都需要更新。

## 字面值常量类
constexpr函数的参数和返回值必须时字面值类型。

**字面值常量类**
数据成员都是字面值类型的聚合类时字面值常量类。

符合下述要求的也是字面值常量类：
1. 数据成员都必须是字面值类型
2. 类必须至少含有一个constexpr构造函数
3. 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类型，则初始值必须使用成员自己的constexpr构造函数
4. 类必须使用析构函数的默认定义，该成员负责销毁类的对象


- constexpr构造函数一般来说应该是空的，通过constexpr就可以声明一个constexpr构造函数。
- constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。

## 类的静态成员
### 声明静态成员
在成员的声明之前加上关键字static使得其与类关联在一起。
1. 类的静态成员存在于任何对象之外，对象中不包含任何于静态成员有关的数据。
2. 静态数据成员被所有类对象所共享
3. 静态成员函数也不与任何对象绑定在一起，它们不包含this指针。
4. 使用静态数据成员`类名::静态数据成员`

### 定义静态成员
`static`关键字只能出现在类的内部。

必须在类的外部定义和初始化每个静态成员，和其他对象一样，一个静态数据成员只能定义一次。

1. 必须在类的外部定义和初始化每个静态成员，静态数据成员只能被定义一次
2. 把静态数据成员的定义与其他非内联函数的定义放在同一个文件中
3. 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员
4. 静态数据成员可以是不完全类型(只声明未定义)。
5. 静态数据成员的类型可以就是它们所属的类类型，而非静态数据成员则受到限制，只能声明称它们所属类的指针或引用。

