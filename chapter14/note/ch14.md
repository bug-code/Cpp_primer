# 重载运算与类型转换
## 基本概念
重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。
```
返回类型 operator运算符(参数列表){}
```
1. 除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参。
2. 当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的显式参数数量比运算对象的数量少一个。
3. 对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数。
4. 重载运算符不能改变其含义。

**运算符**

可被重载的运算符|  | | |||
---------|----------|---------|--------|--------|--------------
 + | - | *| /| %|^
 & | \| | ~ | !|，| =
< |>|<=|>=|++|--
<<|>>|==|!=|&&|\|\||
+=|-=|/=|%=|^=|&=
\|=|*=|<<=|>>=|[ ]|()
->|->*|new |new[]|delete|delete[ ]
**不能被重载的运算符**|
::|.*|.|?:

#### 直接调用一个重载的运算符函数
1. 将运算符作用域类型正确的实参进行间接调用
2. 像调用普通函数一样直接调用

#### 某些运算符不应该被重载
通常情况下不应该重载逗号、取地址、逻辑与和逻辑或运算符
#### 使用与内置类型一致的含义
1. 当在内置的运算符和我们自己的操作之间存在逻辑映射关系时，运算符重载的效果最好
2. 只有当操作的含义对于用户来说清晰明了时才使用运算符
3. 如果用户对运算符可能有几种不同的理解，则使用这样的运算符将产生二义性

#### 赋值和复合赋值运算符
如果类含有算术运算符或位运算符，则最好也提供对应的复合赋值运算符
#### 选择作为成员或非成员
1. 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。
2. 如果想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数。
3. 非成员函数的唯一要求是至少有一个运算对象是类类型

## 输入和输出运算符 （非成员函数）
### 重载输出运算符`<<`
通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。
1. 非常量是因为向流写入内容会改变其状态
2. 引用时因为唔该直接复制一个ostream对象

第二个形参一般来说是一个常量的引用
1. 引用是因为避免复制实参
2. 常量是因为不想改变其值

返回ostream形参

#### 输出运算符尽量减少格式化操作
令输出运算符尽量减少格式化操作可以使用户有权控制输出的细节。例如`endl`
**通常输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符**
#### 输入输出运算符必须是非成员函数
必须是非成员函数，否则它们的左侧运算对象将是我们的类的一个对象。
同时还需将输入输出运算符声明为类的友元。

### 重载输入运算符 
与输出运算符相似，不过第二个形参必须是歌非常量引用，因为要向对象写入数据
**输出运算符必须处理输入可能失败的情况，而输出运算符不需要**
#### 输入时的错误
当执行输入运算符时可能发生下列错误：
1. 当流含有错误类型的数据时读取操作可能失败
2. 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败

- 如果发生错误钱对象已经有一部分被改变，则适时地将对象置为合法状态显得异常重要。
- 通常将对象置为合法地状态，我们能保护使用者免于受到输入错误地影响。

**当读取操作发生错误时，输入运算符应该负责从错误中恢复。**
#### 标示错误
一些输入运算符需要做更多数据验证的工作。
通常情况下：
1. 输入运算符只设置failbit
2. 设置eofbit表示文件耗尽
3. 设置badbit表示流被破坏

## 算术和关系运算符 （非成员函数）
通常情况下，将算术和关系运算符定义成**非成员函数**以允许对左侧或右侧的运算符进行转化。形参都是常量的引用。
**最有效的方法是使用复合赋值来定义算术运算符**
**如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。**

### 相等运算符
设计准则：
1. 如果类定义了operator== ,则也应该定义一个operator!=。其中一个为真正执行相等判断的操作，另一个调用该操作。
2. 如果某个类在逻辑上有相等性的含义，则该类应该定义operator== ， 这样做可以使得用户更容易使用标准库算法来处理这个类。

### 关系运算符
通常情况下关系运算符应该：
1. 定义顺序关系，令其与关联容器中对关键字的要求一致
2. 如果类同时也含有`==`运算符的话，则定义一种关系令其与`==`保持一致。特别是如果两个对象是`!=`的，那么一个对象应该`<`另一个。
3. **如果存在唯一一中逻辑可靠的`<`定义，则应该考虑为这个类i当以`<`运算符。如果类同时还包含`==`，则当且仅当`<`定义和`==`产生的结果一致时才定义`<`运算符**


## 赋值运算符 （成员函数）
除了拷贝赋值运算符，移动赋值运算符外，类还可以定义其他赋值运算符以使用别的类型作为右侧的运算对象。

**我们可以重载赋值运算符，不论形参类型是什么，赋值运算符都必须定义为成员函数**

### 复合赋值运算符 `+=`
复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在**类的内部**。

**赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做，这两类运算符都应该返回左侧运算对象的引用。**

## 下标运算符 (成员函数)
表示容器的类通常可以通过元素在容器中的位置访问元素。下标运算符必须是成员函数。如果**一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。**

## 递增和递减运算符 （成员函数）
1. 递增和递减改变的正好师所操作对象的状态，所以建议将其设定为成员函数
2. **定义递增和递减运算符的类应该同时定义前置版本和后置版本，这些运算符通常应该被定义成类的成员**
3. **为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用**

### 区分前置和后置运算符 （不检查有效性）
1. 后置版本接收一个额外（不被使用）int类型的形参。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。
2. **为了与内置版本保持一致，后置运算符应该返回对象的原值(递增或递减之前的只)，返回的形式是一个值而非引用**
3. **不会用到int形参，所以无须命名**
### 显式调用后置运算符
向形参传递实参。
```
p.operator++(0);//后置
p.operator++();//前置
```
## 成员访问运算符 （* ->）（成员函数）
**箭头运算符必须是类的成员，解引用运算符通常也是类的成员，尽管并非必须如此。**
1. 箭头运算符永远不能丢掉成员访问这个最基本的含义。
2. 对于形如`point->mem`的表达式来说，point必须是只想类对象的指针或者是一个重载了operator->的类的对象。
3. 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。

## 函数调用符
如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更加灵活。
1. 函数调用运算符必须是成员函数，函数调用运算符可重载
2. 如果类定义了调用运算符，则该类的对象称作为**函数对象**。
3. 函数对象常常作为泛型算法的实参

### lambda是函数对象
lambda表达式产生的类中只含有一个重载的函数调用运算符。
**默认情况下由lambda产生的类当中的函数调用运算符是一个const成员函数**
```
bool operator()(参数列表)const;//只有这一个成员，相当于lambda表达式
```
#### 由lambda及相应捕获行为的类
lambda表达式通过引用捕获变量时，将由程序负责lambda执行时引用所引的对象确实存在。**因此通过引用捕获的lambda类可直接使用捕获的变量，而无须存储在其类的内部。**

通过值捕获变量时，需要将其值拷贝至lambda的内部。相当于需要使用类成员额外保存其变量状态。

lambda表达式产生的类不含有默认构造函数、赋值运算符及默认析构函数。其他视捕获的数据成员类型而定。

### 标准库定义的函数对象 (定义在functional中)
1. 标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。
2. 这些类都被定义成模板的形式，可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。

**标准库函数对象**
算术 | 关系 | 逻辑
---------|----------|---------
plus\<type\> | equal_to\<type\> | logical_and\<type\>
minus\<type\> | not_equal_to\<type\> | logical_or\<type\>
multiplies\<type\> | greater\<type\> | logical_not\<type\>
divides\<type\>|greater_equal\<type\>|
modulus\<type\>|less\<type\>|
negate\<type\>|less_equal\<type\>|
#### 在算法中使用标准库函数对象
1. 表示运算符的函数对象类常用来替换算法中的默认运算符
2. **标准库规定其函数对象对于指针同样使用，** 传统中比较两个不同对象的指针是无意义的，但是可以使用标准库中的运算符函数对象类来比较。
### 可调用对象于function
C++语言中有几种可调用的对象:函数、函数指针、lambda表达式、bind创建的对象、以及重载了函数调用运算符的类。

- 和其他对象一样，可调用的对象也有类型。
- 不同类型的可调用对象却可能共享同一种**调用形式**

**例如调用形式：**
```
int(int,int)
``` 
#### 不同类型可能具有相同的调用形式
```
//普通函数
int add(const int& a,const int& b){return a+b;}
//lambda表达式，产生一个未命名的函数对象类
auto mod = [](const int& a  , const int& b){return a%b;};
//函数对象类
class divide{
    public:
        int operator()(const int& den , const int& div){return den/div;};
}
```
以上等，共享同一种调用形式。

当使用同一种调用形式操作时，为了方便可以通过定义一种**函数表**的方式，存储指向这些可调用对象的 **”指针“**。当需要某种操作时，通过函数调用表操作。

```
map<string , int(*)(int , int)> binops; //函数表，不是一种C++特性，只是一种方便操作的map容器
```
可以将普通函数的指针添加到binops中。但是不能将lambda表达式和函数对象类存入该函数表中。
**因为每个lambda有自己的类类型，该类型于存储在binops中的值的类型不匹配。**

#### 标准库function类型 (解决函数表的调用形式不匹配问题)
function的新标准库类型。头文件 **\<functional\>**。

**function的操作**

函数操作 | 含义 
---------|----------
function\<T\> f; | f是用来存储可调用对象的空function,这些可调用的对象的调用形式应该与函数类型T相同 
 function\<T\> f(nullptr); | 显式的构造一个空function 
 function\<T\> f(obj); | 在f中存储可调用对象obj的副本
 f|将f作为条件：当f含有一个可调用对象时为真，反之为假
 f(args)|调用f中的对象，参数是args
定义为function\<T\>的成员的类型|
result_type|该function类型的可调用对象返回的类型、
argument_type|当T有一个或两个实参时定义的类型。如果T只有一个实参，则argument_type是该类型的同义词；如果T有两个实参，则first_argument_type和second_argument_type分别表示两个实参的类型
first_argument_type| 同上
second_argument_type|同上

#### 重载的函数与function
不能直接将重载函数的名字存入function类型的对象中，将存在二义性。解决这一问题的方法：
1. 存入函数指针
```
int (*fp)(int ,int) =add;
binops.insert("+" , fp);
```
2. 使用lambda表达式
```
binops.insert({"+",[](int a ,int b){return add(a,b);}});
```
## 重载、类型转换与运算符
1. 由一个实参调用的非显式构造函数定义了一种隐式的类型转换。**实参类型--->类类型**
2. 通过定义类型转换运算符也可以从类类型到类类型的转换。**类类型--->类类型**
3. 转换构造函数和类型转换运算符共同定义了**类类型转换**，也叫做**用户定义的类型转换**

### 类型转换运算符
**类型转换运算符：**是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。
```
operator type()const;
```
type表示某种类型。类型转换运算符可以面向任意类型进行定义（void除外）。但不允许转换成数组或函数类型。

1. **一个类型转换函数必须是类的成员函数**
2. **不能声明返回类型**
3. **形参列表必须为空**
4. **类型转换函数通常应该是const**

#### 定义含有类型转换运算符的类
均可自动转换
```
class SmallInt{
    private:
        std::size_t val;
    public:
        //构造函数隐式转换，int转向SmallInt
        SmallInt(int i=0):val(i){if(i<0||i>255)throw std::out_of_range("bad SmallInt value");}
    //类类型转换，SmallInt转换为int
    operator int()const{return val;}
}
```
1. **如果在类类型和转换类型之间不存在明显的映射关系，则一般不定义类型转换运算符。**
2. **当不便定义类类型转换运算符时，类可以定义一个或多个普通成员函数以从各种不同形式中提取所需信息。**

#### 类型转换运算符可能产生意外结果
对于类来说，定义转换为bool类型的转换运算符还是比较普遍的。
#### 显式的类型转换运算符 （防止不必要的自动转换）
```
explicit operator int()const {return val;}
```
编译器不会讲一个显式的类型转换运算符用于隐式转换。
如果需要转换则使用如下形式。
```
static_cast<int>(si)+3;//显式的请求类型转换
```
**例外：**
1. 当表达式被用作条件时，编译器会将显式的类型转换自动应用于条件。

#### 转换为bool
向bool的类型转换通常用于在条件部分，因此operator bool一般定义成explicit。
### 避免有二义性的类型转换
如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式。

在两种情况下可能产生多重转换路径：
1. 两个类提供相同的类型转换：例如当A类定义了一个接收B类对象的转换构造函数，同时B类定义了一个转换目标时A类的类型转换运算符时，则它们提供了相同的类型转换。即存在：A类--->B类，同时存在B类--->A类。
2. 类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。例如算术运算符（int ,double,long,short）。**最好只定义最多一个与算术类型有关的转换规则。**

**通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及以上转换源或转换目标时算术类型的转换。**
#### 实参匹配和相同的类型转换
```
class B;
class A{
    A()=default;
    A(const B&);//构造函数隐式转换，B-->A
}
class B{
    operator A()const;//转换运算符，B--->A
}

A f(const A&);
B b;
A a=f(b);//二义性错误，即可调用A的构造函数隐式转换，也可调用B的转换运算符转换
//显式调用函数，强制进行转换可解决
A a1=f(b.operator A()); //转换运算符
A a2=f(A(b));//构造函数
```
#### 二义性与转换目标为内置类型的多重类型转换
如果类定义了一组类型转换，它们的转换源类型本身可以通过其他类型转换联系在一起，则同样会产生二义性的问题。
```
class A{
    A(int a=0);//最好不要创建两个转换源都是算术类型的类型转换
    A(double);
    operator int() const;//最好不要创建两个转换对象都是算术类型的类型转换
    operator double()const;
}
void f2(long double);
A a;
f2(a);//二义性错误：含义时f(A::operator int())
        //还是f(A::operator double())
long lg;
A a2(lg); //二义性错误，含义时A::A(int)还是A::A(double)?
```
**当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个。**

**除了显式的向bool类型的转换之外，我们应该避免定义类型转换函数并尽可能地限制哪些”“显然正确”的非显式构造函数。**

#### 重载函数与转换构造函数
当我们调用重载的函数时，从多个类型转换中进行选择将变得更加复杂。如果两个或多个类型转换都提供了同一种可行匹配，则这些类型转换一样好。
```
class c{
    c(int);
};
class D{
    D(int);
};
void manip(const C&);
void manip(const D&);
manip(10);//二义性错误，含义是manip(C(10))还是manip(D(10))?
manip(C(10));//显式调用构造函数可消除二义性
```
**如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型，则这通常意味着程序的涉及存在不足。**

#### 重载函数与用户定义的类型转换
当调用重载函数时，如果两个(或多个)用户定义的类型转换都提供了可行匹配，则认为这些类型转换一样好。

```
class E{
    E(double);
};
void manip(const C&);
void manip(const E&);
manip(10);//二义性错误，即可调用C类的构造函数精确匹配，也可将int转换成double匹配
```
**在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。**

### 函数匹配与重载运算符
通用的函数匹配规则同样适用于判断在给定的表达式中到底应该使用内置运算符还是重载的运算符。

**表达式中运算符的候选函数集应该包括成员函数，也应该包括非成员函数。**
```
class SmallInt{
    friend SmallInt operator+(const SmallInt&,const SmallInt&);
    privete:
        size_t val;
    public:
        SmallInt(int =0);
        operator int()const{return val;}
};
SmallInt s1,s2;
int i=s2+0;//二义性错误，即可调用+运算符，也可调用转换运算符
```
**如果对同一个类即提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。**

