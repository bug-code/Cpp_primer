# 泛型算法

## 泛型算法概述
** 泛型算法：** 

- **算法：** 实现了一些经典算法的公共接口
- **泛型的：** 可以用于不同类型的元素和多种容器类型

1. `<algorithm>` 大多数算法头文件
2. `<numeric>` 一组数值泛型算法头文件

### 迭代器令算法不依赖于容器，但算法依赖于元素的操作
1. 虽然迭代器的使用令算法不依赖于容器类型，但大多数算法都使用了一个元素类型上的操作
2. 大多数算法都提供了一种方法，允许我们使用自定义的操作来替代默认的运算符

**note:**
1. 算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。
2. 特殊迭代器（如：插入器）可以完成向容器添加元素的效果，但算法自身永远不会这样操作。

如果算法和迭代器组合能执行添加或删除元素操作，则这是特殊迭代器的功劳，而不是算法的功能。泛型算法不会直接添加或删除元素。

## 初识泛型算法
理解算法的最基本方法：了解它们是否读取元素，改变元素或是重排元素顺序
### 只读算法
`find` , `count` , `accumulate` 等都是只读算法。`accumulate`定义在头文件`<numeric>` 中。

**note:** `accumulate`的第三个参数的类型决定了函数中使用哪个假发运算符以及返回值的类型。例如元素类型为int则返回所有元素总和；元素类型为string，则将所有元素连接起来。

`equal`算法，用于确定两个序列是否保存相同的值。算法接受三个迭代器，前两个迭代器表示第一个序列的元素范围，第二个迭代器表示第二个序列的首元素。
**第二个序列中元素个数必须≥前两个迭代器表示的元素范围中元素的个数**
### 写容器元素的算法
**要求：** 序列原大小≥要求算法写入的元素数目，即写入范围内的元素数目≥要写入元素的数目
`fill`接受一堆迭代器表示范围，接受一个值作为第三个参数。fill将值赋予输入序列中的每个元素。
### 算法不检查写操作
向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳写入的元素。如果容器为空，则执行写入操作的结果未定义。

### 初识插入迭代器`back_inserter`
插入迭代器向容器中添加元素的迭代器。`back_inserter`插入迭代器定义在头文件`iterator`中的一个函数。

`back_inserter`插入迭代：
1. 接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。
2. 通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。

**示例：**
```
vector<int> vec;
auto it = back_inserter(vec);
*it = 42;//插入一个元素，值为42
```
```
vector<int> vec;
fill_n(back_inserter(vec),10,0);
```
### 拷贝算法
拷贝算法是另一个向目的位置迭代器指向的输出序列中元素写入数据的算法，接受三个迭代器。

1. 前两个迭代器表示一个输入范围
2. 第三个表示目的序列的起始位置
3. 传输给copy的目的序列至少要包含与输入序列一样多的元素。

**示例：**
```
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];//a1与a2同大小
auto ret=copy(begin(a1) , end(a1) , a2);//将a1内容拷贝给a2
```
**copy返回的是其目的位置迭代器的值。**
多个算法都提供所谓的“拷贝”版本。

`replace`算法读入一个序列，将其中所有等于给定值的元素都改变为另一个值。
**示例：**
```
replace(ilst.begin() , ilst.end() , 0 , 42);//将序列中所有为0的元素都改为42
```
`replace`算法的拷贝版本，`replace_copy`原序列保持不变，此算法接受第三个迭代器参数，指出调整后序列的保存位置。
```
replace_copy(ilst.cbegin() , ilst.end() , back_inserter(ivec) , 0 ,42);//ivec保存ilst序列修改后的值。
```
### 重排容器算法
某些算法会重排元素的顺序。例如：`sort`利用元素类型的`<`运算符来实现排序。
**消除重复值并排序示例：**
```
void elimDups(vector<string> &words){
    sort(words.begin() , words.end());//按字典序排序words，以便查找重复单词。
    auto end_unique = unique(words.begin() , words.end());//unique重排输入范围，返回指向不重复区域之后一个位置的迭代器。
    words.erase(end_unique , words.end());//删除end_unique至最后的的重复元素。
}
```

**unique并不改变序列大小，unique将后面重复的元素值往前覆盖重复的值。此位置之后的元素仍然存在，但不知道它们的值是什么。**

**标准库算法对迭代器而不是容器进行操作。因此，算法不能直接添加或删除元素。**

## 定制操作
很多算法都会比较输入序列中的元素，这类元素类型的<或==运算符来完成比较。标准库允许我们提供自己定义的操作来代替默认运算符。
### 向算法传递函数
**谓词：** 一个可调用的表达式，其返回结果是一个能用作条件的值。

标准库算法使用两类谓词:
1. 一元谓词，只接收单一参数
2. 二元谓词，接受两个参数

**单词按长短排序示例：**
```
bool isShorter(const string &s1,const string &s2){
    return s1.size() < s2.size();
}
sort(words.begin() , words.end() , isShorter);//按长短排序
```

**排序算法**
stable_sort算法，稳定排序算法维持相等元素的原有顺序。
**示例：**
```
elimDups(words);//删除重复值并按字典排序
stable_sort(words.begin() , words.end() , isShorter);//按长度重新排序，长度相同维持原有顺序
```
### lambda表达式
根据算法接受一元谓词还是二元谓词，传递给算法的谓词必须严格接受一个或两个参数。但有时我们希望进行的操作需要更多参数，超过了算法对谓词的限制。

#### lambda介绍
我们可以向一个算法传递任何类别的可调用对象。
**可调用对象：** 可以对其使用调用运算符的对象或表达式

**可调用对象：**
1. 函数
2. 函数指针
3. 重载了函数调用运算符的类
4. lambda表达式

一个lambda表达式表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数。


**lambda表达式形式：**
```
[capture list](parameter list)->return type{function body}
//[捕获列表] (形参列表) 返回类型 函数体
```
lambda表达式可以忽略参数列表和返回类型，但必须包含捕获列表和函数体
```
[capture list]{function body}
```
lambda表达式的返回类型：
1. 如果指定返回类型，则返回指定的返回类型
2. 如果未指定返回类型，但函数体只有一条return语句，则根据return值的类型推断而来
3. 其他返回void

#### 向lambda传递参数
**要求：**
1. 实参和形参类型必须匹配
2. lambda表达式无默认实参
3. 一个lambda只有再其捕获列表中捕获一个它所在函数的局部变量，才能再函数体中使用该变量
4. 捕获列表只用于布局非static变量，lambda可以直接使用局部static变量和它所在函数之外声明的变量
   
#### `for_each`算法
该算法接受一对迭代器表示序列范围，一个可调用对象，并对序列范围中的每一个对象通过调用对象处理。

### lambda捕获和返回
当定义一个lambda时，编译器生成一个与lambda对应的新的未命名类类型。
- 当向一个函数传递lambda时，同时定义了一个新类型和该类型的一个对象；传递的参数就是此编译器生成的类类型的未命名对象。
- 当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象
- 默认情况下，从lambda生成的类包含一个对应的lambda所捕获的变量的数据成员
- lambda的数据成员再lambda对象创建时初始化

**lambda捕获分为：**
1. 值捕获
2. 引用捕获
#### 值捕获
```
[捕获变量](parameter list)->return type{function body}
```
值捕获前提是
1. 变量可拷贝
2. 被捕获的变量在lambda创建时拷贝，不是调用时拷贝

####  引用捕获
```
[&捕获变量](parameter list)->return type{function body}
```
lambda捕获的都是局部变量，因此必须保证
1. 当以引用捕获方式捕获一个变量时，必须保证lambda执行时变量是存在的
2. 如果函数返回一个lambda，则此lambda不能包含引用捕获(不能包含局部变量的引用)
3. 当捕获一个指针或迭代器，或采用引用捕获方式，必须保证lambda执行时，绑定到迭代器，指针，或引用的对象仍然存在
4. 接上 ， 同时保证对象具有预期的值。(在lambda从创建到执行之间，可能有代码改变了绑定的值)

#### 隐式捕获
可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。
1. 当混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是&或=。(指定隐式捕获类型)
2. 当隐式捕获和显式捕获混合使用时，显式捕获必须与隐式捕获方式不同

lambda捕获列表

捕获方式 | 含义 
---------|----------
 [] | 空捕获列表。lambda不能使用所在函数中的变量。一个lambda只有哦捕获变量后才能使用它们 
 [names] | names是一个逗号分隔的名字列表，这些名字都是lambda所在函数的局部变量。默认情况下，捕获列表中的变量都被拷贝。名字前如果使用了&，则采用引用捕获方式 
 [&] | 隐式捕获列表，采用引用捕获方式。lambda体中所使用的来自所在函数的实体都采用引用方式使用
 [=]|隐式捕获列表，采用值捕获方式。lambda体将拷贝所使用的来自所在函数的实体的值
 [&,identifier_list]|identifier_list是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。见混合捕获使用要求
 [=,identifier_list]| identifier_list是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。见混合捕获使用要求。identifier_list中不能包含this.

#### 可变lambda
如果希望改变一个被捕获的变量的值，可以使用两种方式：
1. 使用引用捕获方式
2. 使用值捕获方式，参数列表后添加关键字`mutable`。形式如下
   `[捕获变量] (parameter list) mutable ->return type{function body}`

可变lambda能省略参数列表。`mutable`关键字在改变const类的对象中的成员变量中有讲过。


### 参数绑定 （bind函数）
**解决某些函数只能接受一元谓词与实际需要传入多个参数进行处理的另一种方法**

对于简单操作，使用lambda表达式最有效。对于复杂操作，使用函数方式更合适。

但当某些复杂操作必须使用函数，且需要传入多个参数，而调用该函数的函数只接受一元谓词时，可以使用bind函数。

#### 标准库bind函数
bind函数定义在头文件`functional`中。可以将bind函数看作一个通用的函数适配器。

- bind接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。
  
**bind形式：**
```
auto newCallable = bind(Callable , arg_list);
```
- 其中arg_list表示参数“占位符”，形如`_1 , _2 ,....`
- 占位符表示它们占据了传递给newCallable的参数的位置。

**例如**
```
auto g = bind(f , _2 , _1);
//则g(a,b)==f(b,a)
auto g1 = bind(f1 , _1, a);
//则g1(b)==f1(b, a),g1为一元谓词
```
**使用placeholders名字**
- `placeholders`也定义在头文件`functional`中。

占位符名字`_1,_2,...`等都定义在`std::placeholders`的命名空间中。当要使用占位符时需声明。声明如下
```
using std::placeholders::_1;
using std::placeholders::_2;
....
```
也可以直接使用下列形式
```
using namespace std::placeholders;
```

**bind的参数**
```
auto g = bind(f , a , b , _2, c,_1);
//则g(_1 , _2)==f( a , b , _2, c,_1)
//即g(X,Y) == f(a , b , Y, c,X)
```
bind中的占位符永远都是相对g来说的。

**用bind重排参数顺序**
通过占位符的调整，可以实现函数含义的转换。例如排序函数。

**绑定引用参数**
**ref和cref函数也定义在头文件`functional`中**
- 有时对有些绑定的参数我们希望以引用的方式传递，或是要绑定参数的类型无法拷贝。就必须使用标准库的`ref`函数。

- 函数`ref`返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个`cref`函数，生成一个保存const引用的类。

**示例：**
```
ostream &print(ostream &os , const string &s , char c){
    return os<<s<<c;
}
for_each(vec.cbegin() , vec.cend() , bind(print , cref(os) , _1 , " "));
//ostream是不能拷贝的
```



