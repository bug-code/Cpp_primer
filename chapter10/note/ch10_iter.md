# 再探迭代器
标准库在头文件`<iterator>`中还定义了额外几种迭代器。
1. **插入迭代器：** 这些迭代器被绑定到一个容器上，可用来向容器插入元素
2. **流迭代器：** 这些迭代器被帮i的那个到输入或输出流上，可用来遍历关联的IO流
3. **反向迭代器：**这些迭代器向后而不是向前移动，除了`forward_list`之外的标准库容器都有反向迭代器
4. **移动迭代器：** 这些专用的迭代器不是拷贝其中的元素，而是移动它们

## 插入迭代器
插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。
操作|含义|
----|---|
it=t|在it指定的当前位置插入值t。假定c是it绑定的容器，依赖于插入迭代器的不同种类，此赋值会分别调用`c.push_back(t)`、`c.push_front(t)`或`c.insert(t,p)`，其中p为传递给inserter的迭代器位置|
*it , ++it , it++|这些操作虽然存在，但不会对it作任何事情，每个操作都返回it(因为it是插入迭代器)|

插入器的三种类型，区别在于元素插入位置：
1. `back_inserter`创建一个使用`push_back`的迭代器
2. `front_inserter`创建一个使用`push_front`的迭代器
3. `inserter`创建一个使用`insert`的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。

**note:** 只有容器支持相应的操作才能使用相应的迭代器

**使用插入迭代器时，当成功插入元素后，插入迭代器指向的位置会自动进行调整以便下次使用。**

## iostream迭代器
虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的迭代器。

- `istream_iterator`读取输入流
- `ostream_iterator`读取输出流写数据

这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，可以用泛型算法从流对象读取数据以及向其写入数据。

### `istream_iterator`操作
当创建流迭代器时，有以下要求：
1. 必须指定迭代器将要读写的对象类型
2. 流迭代器的读取类型必须定义了输入运算符和输入运算符
3. 流迭代器的默认初始化为文件输入输出终止符

**示例：**
```
istream_iterator<int> int_it(cin) , int_eof;
//int_it绑定输入流，输入类型为int，int_eof为int类型的默认初始化的输入流终止符

/*istream_iterator最有用的地方*/
vector<int> vec(int_it , int_eof);//流初始化容器，迭代器的优势
```

操作 | 含义 
---------|----------
istream_iterator\<T\> in(is);  | in从输入流is读取类型为T的值 
istream_iterator\<T\> end| 读取类型为T的值的istream_iterator迭代器，表示尾后位置 
in1 == in2 | in1和in2必须读取相同类型 ， 如果它们都是尾后迭代器，或绑定到相同的输入，则两者相等
in1 != in2|同上
*in|返回从流中读取的值
in->mem|与(*in).mem的含义相同 
++in , in++| 使用元素类型所定义的>>运算符从输入流中读取下一个值。与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值

### 使用算法操作流迭代器
可以使用某些泛型算法即类似于`<algorithm>`中的算法来操作流迭代器。
**示例：**
```
istream_iterator<int> in(cin) , eof;
cout<<accumulate(in,eof ,0)<<endl;
```
### istream_iterator允许使用懒惰求值
当讲一个istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到使用迭代器时才真正读取。

**即用即读**

### `ostream_iterator`操作
1. `ostream_iterator`绑定流的类型需要有输出运算符`>>`。
2. 当创建一个`ostream_iterator`时，可以提供(可选的)第二个参数，它是一个C风格字符串，在输出每个元素后都会打印此字符串。
3. 必须将`ostream_iterator`绑定到一个指定的流，不允许空的或表示尾后位置的`ostream_iterator`


操作 | 含义 |
---------|----------
ostream_iterator\<T\> out(os);| out将类型为T的值写到输出流os中 
ostream_iterator\<T\> out(os,d); | out将类型为T的值写到输出流os中，每个值后面都输出一个d。d指向一个空字符结尾的字符数组 
out=val | 用<<运算符将val写入到out所绑定的ostream中。val的类型必须于out可写的类型兼容 
*out , ++out , out++| 这些运算符是存在的，但不对out做任何事情。每个运算符都返回out

**示例：**
```
ostream_iterator<int> out(cout," ");
for(auto &e:vecc ){
    *out++=e; //表格第四行
}
cout<<endl;
```
可以简写成以下
```
ostream_iterator<int> out(cout," ");
for(auto &e:vecc ){
    out=e; //表格第四行 , 与第五行
}
cout<<endl;
```

**通过调用copy来打印vec中的元素，比编写循环更简单**
```
ostream_iterator<int> out(cout," ");
copy(vec.cbegin() , vec.cend() , out);//输出vec中的元素
cout<<endl;
```
## 反向迭代器

反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。递增一个反向迭代器(++it)会移动到前一个元素；递减一个迭代器(--it)会移动到下一个元素。
- 除forward_list之外，其他容器都支持反向迭代器。
- 通过调用rbegin、rend、crbegin、crend成员函数来获得反向迭代器。
- 这些迭代器指向容器尾元素和首元素前一个位置
  
反向迭代器可以透明地向前或向后处理容器。
**示例：**
```
sort(vec.begin() , vec.end());//顺序，从小到大排列
sort(vec.rbegin() , vec.rend());//逆序，从大到小排列
```
### 反向迭代器需要递减运算符
对象需要支持++和--，才能定义反向迭代器。流迭代器不支持递减运算，因此不能从一个forward_list或一个流迭代器创建反向迭代器。
### 反向迭代器和其他迭代器间的关系
通过调用反向迭代器的base成员函数能将反向迭代器转换为普通迭代器。两个迭代器并不是指向同一个元素。
**示例：**
```
it;//it为反向迭代器
it.base() == ++it;//反向迭代器右侧第一个元素
```
# 泛型算法结构
任何算法的最基本的特性是他要求其迭代器提供哪些操作。

下表迭代器类型从上到下层级从低到高
迭代器类别|含义|
----|-----|
输入迭代器| 只读不写，单遍扫描，只能递增|
输出迭代器|只写不读，单遍扫描，只能递增|
前向迭代器|可读写，多遍扫描，只能递增|
双向迭代器|可读写，多遍扫描，可递增递减|
随机访问迭代器|可读写，多遍扫描，支持全部迭代器运算|
## 5类迭代器
类似容器，迭代器也定义了一组公共操作。迭代器是按它们提供的操作来分类的，这种分类形成了一种层次。除了输出迭代器外，高层类别的迭代器支持底层类别迭代器的所有操作。
### 迭代器类别
**输入迭代器：** 必须支持
1. 运算符`==、!=`
2. 运算符`++`
3. 迭代器解引用运算符`*`,解引用运算符智慧出现在赋值运算符右侧
4. 箭头运算符`->`，解引用迭代器，提取对象的成员

**输出迭代器：**必须支持
1. 运算符`++`
2. 解引用运算符`*`，只出现在赋值运算符的左侧，给元素赋值

**前向迭代器：** 单向移动，多次读写，支持输入输出迭代器所有操作

**双向迭代器：** 可以正反向读写序列中的元素，支持递减运算符`--`

**随机访问迭代器：** 提供常量时间内访问序列中任意元素的能力。支持双向迭代器的所有功能。还支持
1. 比较迭代器相对位置的关系运算符`< 、 <= 、>、>=`
2. 迭代器和整数值的加减运算符`+、+=、-、-=`,计算结果是迭代器在序列中移动给定整数个元素后的位置
3. 用于两个迭代器上的减法运算符`-`，得到两个迭代器的距离
4. 下标运算符`[]`，与`*(iter[n])`等价

## 算法形参模式
大多数算法具有如下4中形式之一：
- `alg(beg , end , other args);`
- `alg(beg , end , dest , other args);`
- `alg(beg , end , beg2 , other args);`
- `alg(beg , end , beg2 , end2 , other args);`

### 接受单个目标迭代器的算法
**算法假定：**按其需要写入数据，不管写入多少个元素都是安全的

## 算法命名规范
### 一些算法使用重载形式传递一个谓词
接受谓词参数来替代`<`或`==`运算符的算法，以及哪些不接受额外参数的算法，通常都是重载的函数。
### _if版本的算法
接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词替代元素值。
### 区分拷贝元素的版本和不拷贝的版本
默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。

# 特定容器算法
由于`list`和`forward_list`提供的是双向迭代器和前向迭代器 ， 通用版本的`sort`要求随机访问迭代器。因此定义了其独有的成员函数。

链表版本的算法的性能比对应的通用版本好得多。对于`list`和`forward_list`，应该优先使用成员函数版本的算法而不是通用算法。


`list`和`forward_list`成员函数版本的算法 | 都返回void 
---------|----------
lst.merge(lst2) | 将来自`lst2`的元素合并入`lst`。`lst`和`lst2`都必须是有序的。元素将从`lst2`中删除。在合并之后，`lst2`变为空。第一版本使用`<`运算符；第二版本使用给定的比较操作 
lst.merge(lst2,comp) | 同上 
lst.remove(val) | 调用`erase`删除掉与给定值相等`==`或令一元谓词为真的每个元素
lst.remove_if(pred)|同上|
lst.reverse()|反转`lst`中的元素顺序
lst.sort()|使用`<`或给定比较操作排序的元素
lst.sort(comp)|同上|
lst.unique()|调用`erase`删除同一个值的连续拷贝。第一个版本使用`==`，第二个版本使用给定的二元谓词|
lst.unique()|同上| 

## splice成员
链表特有成员函数。
`list`和`forward_lsit`的`splice`成员函数的参数
`lst.splice(args)`和`flst.splice(args)`


参数 | 含义
---------|----------
( p , lst2) | p是一个指向lst中元素的迭代器，或一个指向flst首前位置的迭代器。函数将lst2的所有元素移动到lst中p之前的位置或是flst中p之后的位置。将元素从lst2中删除。lst2的类型必须与lst或flst相同，且不能是同一个链表 
(p,lst2,p2) | p2是一个指向lst2中位置的有效的迭代器。将p2指向的元素移动到lst中，或将p2之后的元素移动到flst中。lst2可以是与lst或flst相同的链表 
(p , lst2 , b , e) | b和e必须表示lst2中的合法范围。将给定范围中的元素从lst2移动到lst或flst。lst2和lst或flst可以是相同的链表，但p不能指向给定范围中的元素。

## 链表特有操作会改变容器
链表特有版本和通用版本之家的区别在于： **链表版本会改变底层的容器**。
