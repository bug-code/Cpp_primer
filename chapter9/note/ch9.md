# 顺序容器
**顺序容器：** 为程序员提供了控制元素存储和访问顺序的能力。

## 顺序容器概述
容器在以下方面都有不同的性能折中。
1. 向容器添加或从容器中删除元素的代价
2. 非顺序访问容器中元素的代价


顺序容器类型 | 性能描述 
---------|----------
vector | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素会很慢 
deque | 双端队列。支持快速随机访问，在头尾位置插入/删除速度快 
list | 双向列表。只支持双向顺序访问。在list中的任何位置进行插入/删除曹祖速度都很快
forward_list|单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快
array| 固定大小数组。支持快速随机访问。不能添加或删除元素
string|与vector相似的容器，但专门用于保存字符、随机访问快。在尾部插入/删除速度快。

现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。
#### 确定使用哪种顺序容器
**通常使用vector是最好的选择，除非有很好的理由选择其他容器**

选择容器的基本原则：
1. 除非有很好的理由选择其他容器，否则应使用vector
2. 如果程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list
3. 如果程序要求随机访问元素，应使用vector或deque
4. 如果程序要求在容器的头尾插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque
5. 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则
    
    - 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库地sort函数来重排容器中地元素，从而避免在中间位置添加元素。
    - 如果必须在中间位置插入元素，考虑在输入阶段使用list,一旦输入完成，将list中的内容拷贝到一个vector中。

**如果不确定应该使用哪种容器，可在程序中只使用vector和list公共操作：使用迭代器，不使用下标操作，避免随机访问。这样在必要时，选择使用vector或list都很方便。**
### 容器库概览
**对容器可以保存的元素类型的限制**
顺序容器几乎可以保存任意类型的元素。
- 但是如果容器内的类类型没有默认构造函数，则在构造这种容器时不能只传递给它一个元素数目参数：
  
```
vector<noDefault> v1(10,init);///假定noDefault是一个没有默认构造函数的类型，还需提供类的初始化构造器
vector<noDefailt> v2(10);//错误，必须提供一个元素初始化构造器
```


类型别名 | 含义 
---------|----------
 iterator | 此容器类型的迭代器类型 
 const_iterator | 可以读取元素，但不呢个修改元素的迭代器类型 
 size_type | 无符号整数类型，足够保存此种容器类型最大可能容器的大小
 difference_type|带符号整数类型，足够保存两个迭代器之间的距离
 value_type|元素类型
 reference|元素的左值类型，与value_type含义相同
 const_reference|元素的const左值类型（即：const value_type）

 
构造函数 | 含义 
---------|----------
 C c | 默认构造函数，构造空容器 
 C c1(c2) | 拷贝c2的c1 
 C c(b,e) | 构造c，将迭代器b和e指定范围内的元素拷贝到c（不适用array）
 C c(a,b,...,c)|列表初始化c

 
赋值与swap | 含义 
---------|----------
c1=c2 | 将c1中的元素替换为c2中的元素 
 c1={a,b,...,c} | 将c1中的元素替换为列表中元素 （不适用array）
 a.swap(b) | 交换a和b的元素
 swap(a,b)| 与a.swap(b)等价


大小 | 含义 
---------|----------
 c.size() | c中元素的数据（不适用于array） 
 c.max_size() | c中可保存的最大元素数目 
 c.empty() | 若c中存储了元素，则返回false,否则返回true

 
添加/删除元素（不适用于array） | 含义 
---------|----------
 c.insert(args) | 将args中的元素拷贝进c 
 c.emplace(inits) | 使用inits构造c中的一个元素 
 c.erase(args) | 删除args指定的元素
 c.clear()| 删除c中所有元素，返回void

 
关系运算符 | 含义
---------|----------
 ==、!= | 所有容器都支持 
 <,<=,>,>= | 关系运算符(无序关联容器不支持)

 
获取迭代器 | 含义 
---------|----------
 c.begin() , c.end() | 返回指向c的首元素和尾元素之后位置的迭代器 
 c.cbegin() , c.cend() | 返回const_iterator


反向容器的额外成员 | 含义 
---------|----------
reverse_iterator | 按逆序寻址元素的迭代器 
 const_reverse_iterator | 不能修改元素的逆序迭代器 
 c.rbegin() , c.rend() | 返回执行那个c的尾元素和手元素之前位置的迭代器
c.crbegin() ，c.crend() |返回const_reverse_iterator 

#### 迭代器
与容器一样，迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。

标准容器类型上的所有迭代器都允许访问容器中的元素，通过解引用符实现。

**迭代器范围**
由一堆迭代器表示，两个迭代器分别指向同一个容器中的元素或者尾元素之后的位置。**左闭右合区间**
**[begin,end)**

**使用左闭右合范围蕴含的编程假设**
假定begin和end构成一个合法的迭代器范围，则：
1. 如果begin和end相等，则范围为空
2. 如果begin和end不等，则范围内至少包含一个元素，且begin指向该范围中的第一个元素
3. 可以对begin递增若干次，使得begin==end

#### 容器类型成员
如果需要元素类型的一个引用，可以使用reference或const_reference。
#### begin和end成员
当不需要写访问时，应使用cbegin和cend。
#### 容器定义和初始化
每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接收指定容器大小和元素初始值的参数。

定义和初始化 | 含义 
---------|----------
 C c  | 默认构造函数。如果C是一个array,则c中元素按默认方式初始化；否则c为空 
 C c1(c2) | c1初始化为c2的拷贝。c1和c2必须是相同类型(同容器类型，同元素类型，对array类型还需同大小) 
 C c1=c2 | 同上
 C c{a,b,c,...}| c初始化为初始化列表中元素的拷贝。列表中元素的类型必须与c的元素类型相容。对于array类型，列表中元素数目必须小于或等于array大小，任何遗漏的元素都进行值初始化
 C c={a,b,c,...}|同上
 C c(b,e)|c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与C的元素类型相容(array不适用)
 
 只有顺序容器(不包括array)的构造函数才能接收大小参数

定义和初始化 | 含义  
---------|----------
 C seq(n) | seq包含n个元素，这些元素进行了值初始化；此构造函数时explicit的(string不适用) 
 C seq(n,t) | seq包含n个初始化为值t的元素 
 
 **将一个容器初始化为另一个容器的拷贝**
 将一个新容器创建为另一个容器的拷贝的方法有两种：
 1. 直接拷贝整个容器
 2. 拷贝由一对迭代器指定的元素范围(array除外)
   
**当使用迭代器进行初始化时，新容器和原容器中的元素类型可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可**

**当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同**


**与顺序容器大小相关的构造函数**
如果元素类型没有默认构造函数，除了带下参数外，还必须指定一个显示的元素初始值。

**标准库array具有固定大小**
array类型初始化时，初始值的数目必须等于或小于array的大小。如果初始值数目小于array带下，则它们被用来初始化array中靠前的元素，所有剩余元素都会进行值初始化。如果元素类型是一个类类型，那么改类必须有一个默认构造函数，以使值初始化能够进行。

#### 赋值和swap
与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型：
```
array<int, 10> a1={0,1,2,3,4,5,6,7,8,9};
array<int , 10> a2={0};//所有元素均为0
a1=a2; //替换a1中的元素
a2={0}; //错误：不能将一个花括号列表赋予数组
```

**容器赋值运算**

操作 | 含义 
---------|----------
 c1=c2 | 将c1中的元素替换为c2中的元素的拷贝。c1和c2必须具有相同的类型 
 c={a,,b,...} | 将c1中的元素替换为初始化列表中元素的拷贝(array不适用) 
 swap(c1,c2) | 交换c1和c2中的元素，c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快得多

 **assign操作不适用于关联容器和array**

操作 | 含义 
---------|----------
 seq.assign(b,e) | 将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素 
 seq.assign(il) | 将seq中的元素替换为初始化列表il中的元素 
 seq.assign(n,t) | 将seq中的元素替换为n个值为t的元素

赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效(array和string的情况除外)。


**使用swap**
swap分为成员函数版本和非成员函数版本。
**除array外,swap不对任何元素进行拷贝、删除或插入操作，元素本身并未交换，swap只交换了两个容器的内部数据结构**

1. 除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之气那所指向的那些元素 **(整体打包交换)**。string的会全部失效 
2. array容器swap时，容器内的元素会进行交换。swap之后指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素值进行了交换。**(元素进行了交换，其他不变)**

**统一使用非成员函数版本的swap函数**

#### 容器大小操作
**关系运算符**
比较两容器必须满足以下要求：
1. 容器类型相同
2. 容器内元素类型相同
3. 容器内元素类型定义了相应的比较运算符


### 顺序容器操作
#### 顺序容器添加元素
1. 这些元素会改变容器的大小；array不支持这些操作。
2. forward_list有自己专有版本的insert和emplace;
3. forward_list不支持push_back和emplace_back
4. vector和string不支持push_front和emplace_front


操作 | 含义 
---------|----------
 c.push_back(t) | 在c的尾部创建一个值为t或由args创建的元素，返回void 
 c.emplace_back(args) | 同上 
 c.push_front(t) |在c的尾部创建一个值为t或由args创建的元素，返回void  
 c.emplace_front(args)|同上
 c.insert(p,t)|在迭代器p指向的元素之前创建一个值为t或由args创建的元素。返回指向新添加的元素的迭代器
 c.emplace(p,args)|同上
 c.insert(p,n,t)| 在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器；若n为0，则返回p
 c.insert(p,b,e)|将迭代器b和e指定范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素。返回指向新添加的第一元素的迭代器；若范围为空，则返回p
 c.insert(p,il)|il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，则返回p

 **向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用、指针失效**

 **容器元素是拷贝**
 当用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的时对象值的一个拷贝，而不是对象本身。就像将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。

 **在容器中添加元素**
 c.insert()函数。将元素插入到vector、deque和string中的任何位置都是合法的。然而这样做可能很耗时。

 #### 使用insert的返回值
 insert返回指向最新加入元素的迭代器。通过使用insert的返回值，可以在容器中一个特定位置反复插入元素。
 ```
 list<string> lst;
 auto iter=lst.begin();
 while(cin>>word)
    iter = lst.insert(inter,word);//等价于调用push_front
 ```
#### 使用emplace操作
emplace_front、emplace和emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back。

- **emplace操作是使用元素类型的构造函数，构造新元素添加在容器中**

- **emplace函数在容器中直接构造元素。传递给emplace函数必须与元素类型的构造函数相匹配**

#### 访问元素
在顺序容器中访问元素的操作，首先要确保容器非空。
- **at函数和下标操作只适用于string、vector、deque和array**
-  **back不适用于forward_list**

操作 | 含义 
---------|----------
 c.back() | 返回c中尾元素的引用。若c为空，函数行为未定义 
 c.front() | 返回c中尾元素的引用。若c为空，函数行为未定义 
 c[n] | 返回c中下标为n的元素的引用，n是一个无符号整数，若n>=c.size(),则函数行为未定义
c.at(n) |返回下表为n的元素引用，如果下表越界，则抛出一 out of range异常

对一个空容器调用front和back,就像使用一个越界的下标一样，是一种言中国的程序设计错误。

**访问成员函数返回的是引用**

#### 删除元素
删除元素是返回最后一个删除元素之后的迭代器。

- 删除操作会改变容器的大小，所以不适用于array
- forward_list 有特殊版本的erase
- forward_list不支持pop_back;
- vector和string不支持pop_front


操作 | 含义 
---------|----------
 c.pop_back() | 删除c中尾元素。若c为空，则函数行为未定义.函数返回void 
 c.pop_front() | 删除c中首元素。若c为空，则函数行为未定义.函数返回void
 c.erase(p) | 删除迭代器p所致的元素，返回一个指向被删元素之后元素的迭代器，若p指向尾元素，则返回尾后迭代器。若p是尾后迭代器，则函数行为未定义
 c.erase(b,e)| 删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器
 c.clear| 删除c中所有元素，返回void

 1. **删除deque中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效**
 2. **指向vector或string中删除点之后位置的迭代器、引用和指针都会失效**
 3. **删除元素之前，必须确保成员函数参数是存在的**
   
#### 特殊的forward_list操作
forward_list就是单向链表，遵循单向链表的操作要求。


**在forward_list中插入或删除元素的操作**

函数 | 含义 
---------|----------
lst.before_begin() | 返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。cbefore_begin()返回一个const_iterator 
lst.cbefore_begin() | 同上 
lst.insert_after(p,t) | 在迭代器p之后的位置插入元素。t是一个对象，n是数量，b和e是表示范围的一对迭代器(b和e不能指向lst内)。il是花括号列表。返回一个指向最后一个插入元素的迭代器。如果范围为空，则返回p。若p为尾后迭代器，则函数行为未定义。
lst.insert_after(p,b,e) | 同上
lst.insert_after(p,il) | 同上
emplace_after(p,args)|使用args在p指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若p未尾后迭代器，则函数行为未定义。
lst.erase_after(p)|删除p指向的位置之后的元素。或删除从b之后直到(但不包含)e之间的元素。返回一个指向被删元素之后元素的迭代器，若不存在该元素，则返回尾后迭代器。如果p指向lst的尾元素或是一个尾后迭代器，则函数行为未定义。
lst.erase_after(b,e)|同上

#### 改变容器大小
array不支持resize。
**容器大小操作**

操作 | 含义 
---------|----------
 c.resize(n) | 调整c的大小未n个元素。若n<c.size()，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 
 c.resize(n,t) | 调整c的大小为n个元素。任何新添加的元素都被初始化为值t 

如果resize缩小容器，则指向被删除元素的迭代器、引用、指针都会失效。对vector、string或deque进行resize可能导致迭代器、指针和引用失效。

#### 容器操作可能使迭代器失效
在向容器添加元素后：
1. 如果容器是vector或string,且存储空间被重新分配，则指向容器的迭代器、引用、指针都会失效。如果存储空间未重新分配。指向插入位置之前的元素的迭代器、指针、引用仍有效，但指向插入位置之后元素的迭代器、引用、指针都会失效。
2. 对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、引用、指针失效。如果在首尾位置添加位置，迭代器会失效，但指向存在的元素的引用和指针不会失效。
3. 对于list和forward_list，指向容器的迭代器（包括首前和尾后迭代器）、指针、引用仍有效。
   

删除容器中的元素：
1. 对于list和forward_list , 指向容器其他位置的迭代器(包括首前和尾后迭代器)、引用、指针仍有效。
2. 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用、指针也会失效。如果删除deque尾元素，则尾后迭代器也会失效，但其他迭代器、引用、指针不受影响；如果删除首元素，也不受影响
3. 对于vector和string，指向被删元素之前元素的迭代器、引用、指针仍有效。

- **注意删除元素时，尾后迭代器总会失效**
- **添加或删除容器中的元素时可能会使迭代器失效，因此必须保证每次改变容器的操作之后正确的重新定位迭代器**


**不要保存end返沪的迭代器**
在添加或删除元素操作之后，原来end返回的迭代器总是会失效。因此添加或删除元素的循环程序必须**反复调用end**，而不能在循环之前保存end返回的迭代器。


### vector对象使如何增长的
vector中元素是连续存储的。当存储空间不足时，容器必须分配新的内存空间来保存已有元素和新元素，将已有元素从旧位置移动到新空间中。当不得不获取新的内存空间时，vector和string的实现通常会分配必新空间需求更大的内存空间，**多余的留做备用**。

#### 管理容量的成员函数

容器大小管理操作 | 含义 
---------|----------
c.shrink_to_fit() | 请将capacity()减少为与size()相同大小 
c.capacity() | 不重新分配内存的化，c可以保存多少元素 
c.reverse(n) | 分配至少呢个容纳n个元素的内存空间

- shrink_to_fit只适用于vector、string、和deque
- shrink_to_fit只是一个请求，不保证退还内存
- capacity、reserve只适用于vector和string

1. **size**表示容器中已保存元素的数量
2. **capacity**表示容器不分配新内存空间的情况下最多可以保存元素的数量
3. **resize**改变容器中的存储元素的数量
4. **reverse**改变容器的容量

### 额外的string操作
#### 构造string的其他方法

操作 | 含义 
---------|----------
string s(cp,n) | s是cp指向的数组中前n个字符的拷贝。此数组至少应该包含n个字符 
string s(s2,pos2) | s是string s2从下标pos2开始的字符的拷贝。若pos2>s2.size()，构造函数行为未定义 
string s(s2,pos2,len2) | s是string s2从下标pos2开始len2个字符的拷贝。若pos2>s2.size(),构造函数的行为未定义。不管len2的值是多少，构造哈桑农户至多拷贝s2.size()-pos2个字符

*n、len2、pos2都是无符号值*
**子字符串操作**

操作 | 含义 
---------|----------
s.substr(pos,n) | 返回一个string，包含s中pos开始的n个字符的拷贝。pos的默认值为0。n的默认值为s.size()-pos,即拷贝从pos开始的所有字符 

#### 改变string的其他方法
string中insert的重载。
```
s.insert(0,s2);//在s中位置插入s2的拷贝
s.insert(0,s2,0,s2.size());//在s[0]之前插入s2中s2[0]开始的s2.size()个字符
```

修改string的操作
操作 | 含义 
---------|----------
 s.insert(pos,args) | 在pos之前插入args指定的字符。pos可以是一个下标或一个迭代器。接收下标版本返回一个指向s的引用；接收迭代器的版本返回指向第一个插入字符的迭代器
 s.erase(pos,len) | 删除从位置pos开始的len个字符。如果len被省略，则删除从pos开始直至s末尾的所有字符。返回一个指向s的引用 
 s.assign(args) | 将s中的字符替换为args指定的字符。返回一个指向s的引用
 s.append(args)| 将args追加到s。返回一个指向s的引用
 s.replace(range,args)|删除s中范围range内的字符，替换为args指定的字符。range或者是一个下标和一个长度，或者是一对指向s的迭代器。返回一个指向s的引用

 args可以是下列形式之一；append和assign可以适用所有形式。
 str不能与s相同，迭代器b和e不能指向s

字符 | 含义 
---------|----------
 str | 字符串str 
 str , pos , len | str中从pos开始最多len个字 
 cp,len | 从cp指向的字符数组的前（最多）len个字符
 cp|cp指向的以空字符结尾的字符数组
 n,c|n个字符c
 b,e|迭代器b和e指定的范围内的字符
 初始化列表|花括号包围的，以逗号分隔的字符列表

#### string搜索操作
 string搜索函数返回`string::size_type`值，该类型是一个unsigned类型。因此，用一个int或其他带符号类型来保存这些函数的返回值不是一个好主意。

搜索操作返回指定字符出现的下标，如果未找到则返回npos
操作 | 含义 
---------|----------
 s.find(args) | 查找s中args第一次出现的位置 
 s.rfind(args) | 查找s中args最后一次出现的位置 
 s.find_first_of(args) | 在s中查找args中任何一个字符第一次出现的位置 
s.find_last_of(args) | 在s中查找args中任何一个字符最后一次出现的位置
s.find_first_not_of(args)|在s中查找第一个不在args中的字符
s.find_last_not_of(args)|在s中查找最后一个不在args中的字符

args必须是一下形式之一

参数 | 含义 
---------|----------
 c , pos | 从s中位置pos开始查找字符c。pos默认为0 
 s2 , pos | 从s中位置pos开始查找字符串s2。pos默认为0 
 cp,pos | 从s中位置pos开始查找指针cp指向的以空字符结尾的c风格字符串。pos默认为0
cp , pos ,n | 从s中位置pos开始查找指针cp指向的数组的前n个字符。pos和n无默认值

#### compare函数
s.compare的几种参数形式
参数 | 含义 
---------|----------
s2 | 比较s和s2 
pos1 , n1 , s2 | 将s中从pos1开始的n1个字符与s2进行比较 
pos1 , n1 , s2 , pos2 , n2 | 将s中从pos1开始的n1个字符与s2中从pos2开始的n2个字符进行比较
cp|比较s与cp指向的以空字符结尾的字符数组
pos1 , n1 , cp|将s中从pos1开始的n1个字符与cp指向的以空字符结尾的字符数组进行比较
pos1,n1,cp,n2|将s中从pos1开始的n1个字符与指针cp指向的地址开始的n2个字符进行比较 

#### 数值转换
string和数值之间的转换

函数 | 含义 
---------|----------
to_string(val) | 一组重载函数，返回数值val的string表示。val可以是任何算术类型。对每个浮点类型和int或更大的整型，都有相应版本的to_string。与往常一样，小整型会被提升。 
stoi(s,p,b) | 返回s的其实字串的数值，返回类型分别是int、long、unsigned long、long long、unsigned long long。b表示转换所用的技术。默认数值为10。p是size_t指针，用来保存s中第一个非数值字符的下标，p默认为0，即，函数不保存下标 
stol(s,p,b) |同上 
stoul(s,p,b)|同上
stoll(s,p,b)|同上
stoull(s,p,b)|同上
stof(s,p)|返回s的起始子串的数值，返回值类型分别时float、double或long double。参数p的作用与整数转换函数中一样
stod(s,p)|同上
stold(s,p)|同上

### 顺序容器适配器
标准库定义了三个顺序容器适配器：stack、queue和priority_queue。
**一个适配器是一种机制，能使某种事物的行为看起来像另外一种事务一样。**

所有容器适配器都支持的操作和类型

操作 | 含义 
---------|----------
 size_type | 一种类型，足以保存当前类型的最大对象的大小 
 value_type | 元素类型 
 container_type | 实现适配器的底层容器类型 
A a; |创建一个名为a的空适配器
A a(c);|创建一个名为a的适配器，带有容器c的一个拷贝
关系运算符|每个适配器都支持所有关系运算符：==、!=、<、<=、>和>=。这些运算符返回底层容器的比较结果
a.empty()|若a包含任何元素，返回false，否则返回true
a.size()|返回a中的元素数目
swap(a,b)|交换a和b的内容，a和b必须有相同类型，包括底层容器类型也必须相同
a.swap(b)|同上

#### 定义一个适配器
- 默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的。

示例：
```
deque<int> deq;
//因为stack默认是基于deque实现的
stack<int> stk(deq);//从deq拷贝元素到stk
```
- 重载默认容器类型
示例：
```
stack<string , vector<string>> str_stk;//在vector实现空栈
stack<string , vector<string>> str_stk2(svec);//初始化时赋值
```
适配器|要求|可运用的容器|
---|-----|----|
stack|容器具有push_back、pop_back、back操作|除array和forward_list之外的任何容器类型|
queue|容器具有bakc、push_back、front和push_front|list、vector和deque|
priority_queue|容器具有front、push_back和pop_back操作和随机访问能力|vector或deque|

#### 栈适配器
stack类型定义在stack头文件中。

栈操作

函数|含义|
-----|----|
s.pop()|删除栈顶元素，但不返回该元素值|
s.push(item)|创建一个新元素压入栈顶，该元素通过拷贝或移动item而来，或者由args构造|
s.emplace(args)|同上|
s.top()|返回栈顶元素，但不将元素弹出栈|

只可以适用适配器操作，而不能适用底层容器类型的操作。

#### 队列适配器
queue和priority_queue适配器定义在queue头文件中

队列操作
函数|含义|
---|----|
q.pop()|返回queue的首元素或priority_queue的最高优先级的元素，但不返回此元素|
q.front()|返回首元素或尾元素，但不删除此元素。只使用于queue|
q.back()|同上|
q.top()|返回最高优先级元素，但不删除该元素。只适用于priority_queue|
q.push(item)|在queue末尾或priority_queue中恰当的位置创建一个元素，其值为item，或者由args构造|
q.emplace(args)|同上|

priority_queue允许为队列中国的元素建立优先级。默认情况下，标准库在元素类型上适用<运算符来确定相对优先级。
